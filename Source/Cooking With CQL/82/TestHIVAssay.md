# Test HIV Assay

This topic discusses additional questions from the same CQL Zulip thread as Test On ART:

[CQL Coding](https://chat.fhir.org/#narrow/stream/179220-cql/topic/CQL.20Coding)

## Question

Proposed queries:

```cql
//triggeredBy ~ order for Assay 1
define "Continue with performing HIV 'Assay 2'":
[Observation] O
with [O.basedOn -> ServiceRequest] SR
such that (SR.code in {"Assay 1"})
where (O.status in { 'final', 'amended' }
and O.code in { "Rapid diagnostic test for HIV", "Enzyme immunoassay for HIV" }
and O.value in { "Reactive" }
and "Age_greater_than_18_months")
// Output Service Request for Assay 2 
```

```cql
//triggeredBy ~ "Continue with performing HIV 'Assay 2'"
define "Continue with performing HIV 'Assay 1 repeated'":
[Observation] O
with [O.basedOn -> ServiceRequest] SR
such that (SR.reasonCode in "Assay 1 reactive" and
SR.code in {"Assay 2"})
where (O.status in { 'final', 'amended' }
and O.code in { "Rapid diagnostic test for HIV", "Enzyme immunoassay for HIV" }
and O.value in { "Non-reactive" }
and "Age_greater_than_18_months")
// Output Service Request for Continue with performing HIV 'Assay 1 repeated' 
```

Essentially what I'm trying to do is have these definitions linked by service requests that are generated by the previous step. The rule for "Continue with performing HIV 'Assay 1 repeated'" for example has to be linked through the variable basedOn to a ServiceRequest. The reasonCode for this serviceRequest is a codeable concept that from your lesson above I assumed I could just use the 'in' operator to reference a code for "Assay 1 reactive". This however, is not working. 

## Discussion


### Documentation Tags

The documentation here notes "triggeredBy", consider using a tag for this information, it makes it computable in the ELM output:

```cql
/*
@triggeredBy: Order for Assay 1
*/

Also, consider proposing this tag as a [Well-known Documentation Tag](https://github.com/cqframework/clinical_quality_language/wiki/Well-Known-CQL-Documentation-Tags)

### Identifier Conventions

Consider [Identifier Conventions](https://build.fhir.org/ig/HL7/cql-ig/using-cql.html#library-level-identifiers)

So rather than:
```cql
define "Continue with performing HIV 'Assay 2'":
```

Consider:

```cql
define "Should Continue With Performing HIV Assay 2":
```

### Formatting Conventions

Consider [Formatting Conventions - Queries](https://cql.hl7.org/14-g-formattingconventions.html#queries-5)

So rather than:

```cql
//triggeredBy ~ order for Assay 1
define "Continue with performing HIV 'Assay 2'":
[Observation] O
with [O.basedOn -> ServiceRequest] SR
such that (SR.code in {"Assay 1"})
where (O.status in { 'final', 'amended' }
and O.code in { "Rapid diagnostic test for HIV", "Enzyme immunoassay for HIV" }
and O.value in { "Reactive" }
and "Age_greater_than_18_months")
// Output Service Request for Assay 2 
```

Consider:

```cql
/*
@triggeredBy: order for Assay 1
Indicates whether to output Service Request for Assay 2 
*/
define "Should Continue With Performing HIV Assay 2":
  [Observation] O
    with [O.basedOn -> ServiceRequest] SR
      such that (SR.code in {"Assay 1"})
    where (O.status in { 'final', 'amended' }
      and O.code in { "Rapid diagnostic test for HIV", "Enzyme immunoassay for HIV" }
      and O.value in { "Reactive" }
      and "Age_greater_than_18_months")
```

### FHIR References

Although this syntax is correct:

```cql
  [Observation] O
    with [O.basedOn -> ServiceRequest] SR
```

This is a new trial-use feature of CQL (as of 1.5) and is not yet widely supported by the engines; consider a more supported approach

```cql
[Observation] O
  with [ServiceRequest] SR
    such that exists (O.basedOn BasedOn where SR.id = Last(Split(BasedOn.reference, '/'))
```

NOTE: This assumes resources are housed on the same server

Also, consider defining fluent functions to facilitate this reference comparison:

```cql
define fluent function references(reference FHIR.Reference, resource FHIR.Resource):
  resource.id = Last(Split(reference.reference, '/'))  

define fluent function references(references List<FHIR.Reference>, resource FHIR.Resource):
  exists (references R where R.references(resource))
```

NOTE: I will propose these for inclusion in [FHIRCommon](http://fhir.org/guides/cqf/common)

With these, we can then write:

```cql
[Observation] O
  with [ServiceRequest] SR
    such that O.basedOn.references(SR)
```

NOTE: See [FHIR References](https://github.com/cqframework/CQL-Formatting-and-Usage-Wiki/blob/master/Source/Cooking%20With%20CQL/56/FHIRReferencesRevisited.cql) for more information

### Terminology

Looking at the terminology for determining the "Assay 1" test:

```cql
[Observation] O
  with [ServiceRequest] SR
    such that O.basedOn.references(SR) and SR.code in { "Assay 1" }
```

If "Assay 1" is a `Code`, then promoting to a list like this to get it to be treated like a value set is an anti-pattern, because although it will work, it will use _equality comparison_, rather than _equivalent comparison_.

So, if it's a code, use the terminology equivalence operator:

```cql
[Observation] O
  with [ServiceRequest] SR
    such that O.basedOn.references(SR) and SR.code ~ "Assay 1"
```

If it's a `ValueSet`, then there is no need to promote it to a list, so the braces are unnecessary:

```cql
[Observation] O
  with [ServiceRequest] SR
    such that O.basedOn.references(SR) and SR.code in "Assay 1"
```

#### ValueSet Usage

Note that best-practice for terminology filtering is to use ValueSets, for multiple reasons:

1. It facilitates identifying terminology requirements and writing logic that makes use of them without necessarily resolving the exact codes required yet
2. It provides an easier way for implementations to deal with and understand the terminologies involved (i.e. mapping support)
3. It facilitates supporting multiple code systems (i.e. identifying the Assay 1 tests in multiple potential code systems) 
    a. For this use case, best-practice is to define value sets for each code system, then use a "grouping" value set to bring them together, it makes managing the value sets themselves easier over time)

And note that best-practice is to move the terminology filter to the retrieve where possible:

```cql
[Observation] O
  with [ServiceRequest: "Assay 1"] SR
    such that O.basedOn.references(SR)
```

### Additional Filtering

Looking at the rest of the `where` clause:

```cql
    where (O.status in { 'final', 'amended' }
      and O.code in { "Rapid diagnostic test for HIV", "Enzyme immunoassay for HIV" }
      and O.value in { "Reactive" }
      and "Age_greater_than_18_months")
```

If "Rapid diagnostic test for HIV" and "Enzyme immunoassay for HIV" are `Code`s, then again, this is an anti-pattern to create a list like this, because it will result in the use of _equality_ rather than _equivalent_ comparisons. Instead, create a value set for these:

```cql
valueset "HIV Diagnostic Tests": 'http://example.org/fhir/ValueSet/hiv-diagnostic-tests' // Include the Rapid diagnostic test for HIV and Enzyme immunoassay for HIV codes in this value set
```

And then move the filter for the test into the retrieve:

```cql
[Observation: "HIV Diagnostic Tests"] O
  with [ServiceRequest: "Assay 1"] SR
    such that O.basedOn.references(SR)
  where (O.status in { 'final', 'amended' }
    and O.value in { "Reactive" }
    and "Age_greater_than_18_months")
```

Looking at the "Reactive", if it is a `Code`, this should be an equivalence operator (`~`), otherwise, drop the braces:

```cql
[Observation: "HIV Diagnostic Tests"] O
  with [ServiceRequest: "Assay 1"] SR
    such that O.basedOn.references(SR)
  where (O.status in { 'final', 'amended' }
    and O.value in "Reactive"
    and "Age_greater_than_18_months")
```

And a final note about conventions here, just like SQL, `and` has a higher precedence than `or`, allowing for most queries that contain only `and`s to be written without parentheses:

```cql
[Observation: "HIV Diagnostic Tests"] O
  with [ServiceRequest: "Assay 1"] SR
    such that O.basedOn.references(SR)
  where O.status in { 'final', 'amended' }
    and O.value in "Reactive"
    and "Age_greater_than_18_months"
```

And a note about formatting, if you do need the parentheses (because of nested `or` and `and`, consider the formatting convention of putting the ending parentheses on the next line:

```cql
[Observation: "HIV Diagnostic Tests"] O
  with [ServiceRequest: "Assay 1"] SR
    such that O.basedOn.references(SR)
  where (O.status in { 'final', 'amended' }
    and O.value in "Reactive"
    and "Age_greater_than_18_months"
  )
```

This makes it easier to see blocks of related criteria.

### Patient Age

The filter also makes use of a definition for "Age_greater_than_18_months".

First, from a conventions standpoint, the identifier should be:

```cql
"Age Greater Than 18 Months"
```

Second, this definition doesn't convey anything more than the equivalent logic would,

```
AgeInMonths() > 18
```

Consider just using the built-in age calculation functions, rather than defining a separate expression for that.

### Terminology Followup

A followup question was asked, 

> Does That mean I have to create custom ValueSets every time I want to filter by a speific list of codes? 
> Is there a way I can define that Custom valueset that contains a List of spefific codes with in CQL or it has to be an actual valueSet I have already defined outside CQL?

And the answer is no, there is not a way to define a valueset as a list of codes in CQL, and that is by design. As noted in the terminology section above, terminology management is a non-trivial problem, and CQL is intentionally silent on how that happens, separating that as an architectural concern. CQL allows you to reference any terminologies you have defined, but CQL is not a terminology management language. It is focused on making use of properly managed terminologies.

That being said, it is straightforward to define ValueSet resources either directly in JSON, or with FSH and then use the SUSHI compiler to generate the JSON. Once you have JSON ValueSet resources, adding them to the vocabulary folder in the IG will make them available to the CQL engine for testing and evaluation. See [Using Terminology](https://github.com/cqframework/vscode-cql/wiki/User-Guide#using-terminology) in the VS Code CQL Plugin User's Guide for more information

### Updated Queries:

So going back to the initial queries:

```cql
//triggeredBy ~ order for Assay 1
define "Continue with performing HIV 'Assay 2'":
[Observation] O
with [O.basedOn -> ServiceRequest] SR
such that (SR.code in {"Assay 1"})
where (O.status in { 'final', 'amended' }
and O.code in { "Rapid diagnostic test for HIV", "Enzyme immunoassay for HIV" }
and O.value in { "Reactive" }
and "Age_greater_than_18_months")
// Output Service Request for Assay 2 
```

```cql
//triggeredBy ~ "Continue with performing HIV 'Assay 2'"
define "Continue with performing HIV 'Assay 1 repeated'":
[Observation] O
with [O.basedOn -> ServiceRequest] SR
such that (SR.reasonCode in "Assay 1 reactive" and
SR.code in {"Assay 2"})
where (O.status in { 'final', 'amended' }
and O.code in { "Rapid diagnostic test for HIV", "Enzyme immunoassay for HIV" }
and O.value in { "Non-reactive" }
and "Age_greater_than_18_months")
// Output Service Request for Continue with performing HIV 'Assay 1 repeated' 
```

And applying the above considerations, we have:

```cql
/*
@description: Indicates whether to output Service Request for Assay 2 
@triggeredBy: Order for Assay 1
*/
define "Should Continue With Performing HIV Assay 2":
  [Observation: "HIV Diagnostic Tests"] O
    with [ServiceRequest: "Assay 1"] SR
      such that O.basedOn.references(SR)
    where O.status in { 'final', 'amended' }
      and O.value in "Reactive"
      and AgeInMonths() > 18
```

and

```cql
/*
@description: Indicates whether to output a Service Request for Assay 1
@triggeredBy: Order for Assay 2
*/
define "Continue With Performing HIV 'Assay 1 repeated'":
  [Observation: "HIV Diagnostic Tests"] O
    with [ServiceRequest: "Assay 2"] SR
      such that O.basedOn.references(SR)
  where O.status in { 'final', 'amended' }
    and O.value in "Non-reactive"
    and AgeInMonths() > 18
```